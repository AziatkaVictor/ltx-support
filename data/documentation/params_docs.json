{
    "on_info": {
        "documentation": "Самый простой и распространённый параметр, сам по себе никаких особых функций не несёт. Нужен для выполнения действий с помощью `Condlist`. Обычно нужен для смены секции или выполнения действия по условию.",
        "example": "on_info = {!has_item(item)} %=give_item(item)% nil"
    },
    "on_signal": {
        "documentation": "Вызываеться при получении определённого сигнала. Считаеться только сигнал для этой логики, потому что сигналы из других объектов вне зоны видимости. Обычно используеться для моментов, которые занимают некоторое время для выполнения, например, проигрывание звука или катсцены.",
        "example": "on_signal = sound_end | %=give_task(task_name)% sr_idle@wait"
    },
    "on_game_timer": {
        "documentation": "Вызываеться по истечению таймера. В отличии от `on_timer`, здесь используеться игровое время, поэтому сон и скорость игрового времени влияют на таймер. Расчет времени таймера идет по такой формуле: `количество секунд` * `игровое время`.",
        "example": "on_game_timer = 200 | %=send_tip(text)% sr_idle@end"
    },
    "on_timer": {
        "documentation": "Вызываеться по истечению таймера. В отличии от `on_game_timer`, здесь используеться реальное время в милисекундах, поэтому сон и скорость игрового времени не влияют на таймер. Расчет времени таймера идет по такой формуле: `количество секунд` * `1000`.",
        "example": "on_timer = 2000 | %=send_tip(text)% sr_idle@end"
    },
    "on_press": {
        "documentation": "Вызываеться при \"использовании\" объекта, в которой прописана логика. Используеться обычно для рычагов или интерактивного радио.",
        "example": "on_press = %=play_sound(sound)% ph_idle@end"
    },
    "tooltip": {
        "documentation": "Текст, который высвечивается при наведении мышки на объект, в которой указана логика. Должен быть прописанным в файлах локализации. Используеться во многих интерактивных предметах, таких как: ящики, кнопки, двери и прочее.",
        "example": "tooltip = st_text"
    },
    "active": {
        "documentation": "Указывает начальную секцию при старте работы логики.",
        "example": "active = sr_idle@start"
    },
    "on_actor_inside": {
        "documentation": "Вызывается в момент, когда игрок заходит внутрь рестриктора. Не работает, если у объекта нету рестриктора.",
        "example": "on_actor_inside = %=give_task(task)% sr_idle@inside"
    },
    "on_actor_outside": {
        "documentation": "Вызывается в момент, когда игрок выходит из рестриктора. Не работает, если у объекта нету рестриктора.",
        "example": "on_actor_outside = %=give_task(task)% sr_idle@outside"
    },
    "cam_effector": {
        "documentation": "Указывает `*.anm` файл, который хранит информацию о катсцене, положении камеры и таймингах. Указывается относительно `gamedata\\anims\\camera_effects`.",
        "example": "cam_effector = camera_name_1"
    },
    "global_cameffect": {
        "documentation": "Запускать камеру в глобальном пространстве. Активируется если true, иначе катсцена будет проигрываться в 0 позиции мира.",
        "example": "global_cameffect = true"
    },
    "anim": {
        "documentation": "Указывает анимацию для объекта.",
        "example": "anim = idle"
    },
    "on_actor_in_zone": {
        "documentation": "Вызывается, когда игрок внутри зоны с указаным `Story_ID`. Работа аналогична `on_actor_inside`, с разницей в том, что можно указывать стороние объекты, которые с текущей логикой не имеют ничего общего.",
        "example": "on_actor_in_zone = zone_id | %=give_task(task)% sr_idle@inside"
    },
    "on_actor_not_in_zone": {
        "documentation": "Вызывается, когда игрок снуружи зоны с указаным `Story_ID`. Работа аналогична `on_actor_outside`, с разницей в том, что можно указывать стороние объекты, которые с текущей логикой не имеют ничего общего.",
        "example": "on_actor_not_in_zone = zone_id | %=give_task(task)% sr_idle@outside"
    },
    "invulnerable": {
        "documentation": "Параметр, который отвечает за получение урона. Если указать `true`, то персонаж не сможет умереть.",
        "example": "invulnerable = true"
    },
    "meet": {
        "documentation": "Указывает настройки приветствия, например, что будет говорить НПС и какую анимацию ему нужно проиграть при приближении или отдалении игрока. Необходимо указывать ссылку на секцию типа `meet`. Так же можно указать `no_meet`, это настройки, которые уже заранее заготовленны в скриптах, которые полностью отключают все возможные взаемодействия с НПС: запрещаеться говорить, торговать, т.д.",
        "example": "meet = meet@trade\nmeet = no_meet"
    },
    "use_camp": {
        "documentation": "Использование НПС фонарика. Если указать `false`, то фонарик будет выключен. Очень удобно для ситуаций, когда НПС находится в освещенном помещении и фонарик не только не в тему, но и будет лишний раз нагружать игру. Так же полезно для использования в сюжетных моментах.",
        "example": "use_camp = false"
    },
    "storyline": {
        "documentation": "Параметр для конфигурации заданий, который указывает, является ли это задание второстепенным. Если указать `true`, то задание будет помечено как сюжетное.",
        "example": "storyline = true"
    },
    "cover_name": {
        "documentation": "Название animpoint-а, в котором будет находиться НПС. Если не указывать `avail_animations`, будет использовать анимацию, которую указана по умолчанию, в SDK, внутри самого animpoint-а.",
        "example": "cover_name = esc_cover_name_1"
    },
    "avail_animations": {
        "documentation": "Название анимации, которая будет проигрываеться. Если анимация уже была указана в СДК, то просто будет её перезаписывать.",
        "example": "avail_animations = sleep"
    },
    "gather_items_enabled": {
        "documentation": "Разрешено ли НПС подбирать предметы, Очень полезный параметр, который позволит ограничить НПС в важных сюжетных моментах. Если указать `false` то НПС более не станет подбирать предметы. Можно использовать условия, для более гибкой настройки.",
        "example": "gather_items_enabled = false"
    },
    "combat_ignore_cond": {
        "documentation": "Игнорировать ли НПС сражения? Полезно для сюжетных моментов или банального ограничения НПС, которые находятся на базе, чтобы они не агрились на ближайщих врагов. Можно использовать условия, для более гибкой настройки.",
        "example": "combat_ignore_cond = true\ncombat_ignore_cond = {+has_info} false, true"
    },
    "combat_ignore_keep_when_attacked": {
        "documentation": "Схоже с `combat_ignore_cond`, однако в отличии от него, лишь регулирует рекцию, если НПС был атакован. Можно использовать условия, для более гибкой настройки.",
        "example": "combat_ignore_keep_when_attacked = true\ncombat_ignore_keep_when_attacked = {+has_info} false, true"
    },
    "path_walk": {
        "documentation": "Указывает waypoint который подразумевает позицию НПС. Можно указывать waypoint со множеством точек. Более гибкая настройка поведения в этих waypoint-ах происходит в SDK.",
        "example": "path_walk = waypoint_name_1_walk"
    },
    "path_look": {
        "documentation": "Указывает waypoint который подразумевает поворот НПС (точку, куда он будет смотреть). Можно указывать waypoint со множеством точек. Более гибкая настройка поведения в этих waypoint-ах происходит в SDK.",
        "example": "path_look = waypoint_name_1_look"
    },
    "allow_break": {
        "documentation": "Разрешено ли прерывать диалог, если указан `false`, то диалог нельзя будет закончить без нажать на специальный ответ, который сам закроет диалогове окно.",
        "example": "allow_break = false"
    }
}